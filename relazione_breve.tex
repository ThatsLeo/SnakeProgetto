\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,                 
    breakatwhitespace=true,
    columns=flexible,
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{Relazione Tecnica: Principali Scelte Implementative\\del Progetto Snake}
\author{Studenti:\\ 
\texttt{matteo.terzi8@studio.unibo.it}\\ 
\texttt{francesco.pignanelli@studio.unibo.it}\\ 
\texttt{leonardorocco.monaco@studio.unibo.it}
}
\date{}

\begin{document}
\sloppy

\maketitle

\section{Introduzione}

Il progetto Snake è stato sviluppato in C++ usando la libreria ncurses. Il gioco è organizzato in moduli separati: uno per la logica di gioco, uno per i menu, uno per salvare i dati e uno per le funzioni di supporto.

\section{Architettura del Sistema}

\subsection{Organizzazione Del Progetto}

Il progetto è diviso in cartelle diverse, ognuna con un compito specifico:

\begin{itemize}
    \item \texttt{gioco/}: contiene tutto quello che serve per far funzionare il gioco, il serpente in (\texttt{Serpente.cpp/hpp}), la mela in (\texttt{Mela.cpp/hpp}) e i livelli in (\texttt{Livelli.cpp/hpp}). In (\texttt{game.cpp}) viene gestita la logica vera e propria del gioco con i relativi tempi, punteggi e collisioni tra oggetti.
    
    \item \texttt{menu\_handler/}: gestisce il menu principale del gioco (\texttt{main\_menu.cpp/h}): Contiene 4 scelte ovvero 'Gioca', 'Classifica', 'Livelli' ed 'Esci'. Premendo 'Gioca' si avvierà l'ultimo livello selezionato tramite la sezione 'Livelli' del menu.
    
    \item \texttt{file\_handler/}: si occupa di salvare e leggere i punteggi dal file (\texttt{file\_manager.cpp/h})
    
    \item \texttt{utils/}: contiene funzioni utili usate in tutto il progetto (\texttt{utils.cpp/h})
    \item \texttt{includes/}: raccoglie tutte le librerie e le costanti comuni che vengono incluse in ogni file del progetto(\texttt{include.h/cpp})
\end{itemize}

\subsection{Scelte Fondamentali}

\textbf{Utility Class}: La classe \texttt{Utils} contiene funzioni statiche per operazioni comuni (timing, gestione finestre, colori).

\textbf{Variabili Globali}: Usiamo variabili globali (\texttt{levelChosen}, \texttt{punteggioFinale}) per tenere sempre traccia delle variabili importanti.

\textbf{Gestione Manuale della Memoria}: Controlliamo direttamente quando allocare e liberare la memoria per oggetti e finestre ncurses, quando avviene un gameOver viene deallocata la memoria di ogni oggetto di gioco.

\section{Implementazione del Game Loop}

\subsection{Architettura Temporizzata}

Il centro del gioco è la funzione \texttt{start\_game()}:

\begin{lstlisting}[language=C++]
double moveDelay = CLOCKS_PER_SEC / (7.0 + (levelChosen - 1) * 0.666);
int levelDelay = 45; // secondi per livello
int bonusPoints = 100 * livello->getId();
\end{lstlisting}

\textbf{Timer Separati}: Usiamo tre timer diversi per il movimento del serpente, per far apparire le mele e per la durata del livello.

\textbf{Input Non-Bloccante}: \texttt{nodelay(win, TRUE)} fa sì che il gioco non si fermi mentre aspetta che l'utente prema un tasto.

\subsection{Sistema di Input Responsivo}

Il sistema per gestire i tasti premuti usa diverse strategie:

\begin{itemize}
    \item \textbf{Pulizia Buffer}: \texttt{flushinp()} cancella i tasti premuti in precedenza prima di operazioni importanti
    \item \textbf{Ultimo Tasto}: Consideriamo solo l'ultimo tasto premuto, ignorando quelli bufferizzati
    \item \textbf{Controllo Direzione}: Evitiamo che il serpente vada nella direzione opposta subito, per non causare collisioni accidentali
\end{itemize}

\section{Strutture Del Progetto}

\subsection{Implementazione del Serpente}

La classe \texttt{Serpente} usa una lista collegata per rappresentare il corpo del serpente:

\begin{lstlisting}[language=C++]
struct body {
    int y, x;
    body* next;
};
\end{lstlisting}

\textbf{Movimento}: Aggiungiamo un nuovo pezzo in testa e togliamo quello in coda.

\textbf{Attraversamento Bordi}: Quando il serpente esce da un lato dello schermo, riappare dal lato opposto.

\textbf{Controllo Collisioni}: Un algoritmo che controlla se la testa del serpente tocca qualche pezzo del suo corpo.

\subsection{Gestione delle Mele}

La classe \texttt{Mela} fa apparire le mele solo in posti liberi:

\begin{lstlisting}[language=C++]
bool isCellEmpty(WINDOW* win, int y, int x) {
    chtype ch = mvwinch(win, y, x);
    char currentChar = ch & A_CHARTEXT;
    return (currentChar == ' ');
}
\end{lstlisting}

Le mele vengono create solo dove non c'è il serpente, ogni volta che una mela viene mangiata viene generata una nuova posizione casuale, fin quando la posizione generata è occupata un ciclo while continuerà a generarne di nuove.

\subsection{Implementazione Livelli}

I livelli sono implementati tramite lista bidirezionale, ogni livello ha un proprio ID tramite il quale vengono gestiti i tempi del movimento, i punteggi delle mele e dei punti bonus.


\section{Sistema Di Classifica}

\subsection{File-Based Storage}

Per salvare i dati usiamo un semplice file di testo:

\begin{lstlisting}[language=C++]
void FileManager::writeFileAppend(const std::string toWrite) {
    std::ofstream outputFile; 
    outputFile.open("SaveFile.txt", std::ios_base::app);
    outputFile << toWrite;
    outputFile.close();
}
\end{lstlisting}

\textbf{Formato Strutturato}: I dati sono salvati nel formato \texttt{"Nome:Punteggio"} che è facile da leggere e interpretare.

\textbf{Solo Aggiunte}: I nuovi punteggi vengono sempre aggiunti in fondo al file, senza cancellare quelli vecchi ma nella classifica del gioco vengono mostrati solo i primi 10 evidenziando i primi 3, per ordinare i punteggi usiamo un bubble sort.

\section{Gestione Errori e Robustezza}

\subsection{Input Validation}

\begin{itemize}
    \item \textbf{Controllo Esistenza File}: Verifichiamo che il file esista con \texttt{is\_open()} prima di leggerlo
    \item \textbf{Controllo Punteggio}: Salviamo solo punteggi maggiori di zero
    \item \textbf{Sicurezza Stringhe}: Aggiungiamo sempre il carattere di fine stringa e usiamo \texttt{strncpy()} per evitare overflow
\end{itemize}

\end{document}
